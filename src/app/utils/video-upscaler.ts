import { Resolution, resolutionSettings } from "./resolutions";
// Dynamically import ffmpeg only when needed (mp4 conversion)
// Using FFmpeg v0.12.x requires importing from correct exports
type FFmpegModule = {
  fetchFile: (file: File | Blob | string) => Promise<Uint8Array>;
  FFmpeg: new () => any;
};

interface VideoInfo {
  width: number;
  height: number;
  duration: number;
  fileSize: number;
}

interface UpscaleOptions {
  resolution: Resolution;
  bitrate: number; // in Mbps
  format?: "webm" | "mp4"; // mp4 support via ffmpeg.wasm
}

export async function getVideoInfo(file: File): Promise<VideoInfo> {
  return new Promise((resolve, reject) => {
    const video = document.createElement("video");
    video.preload = "metadata";

    video.onloadedmetadata = () => {
      URL.revokeObjectURL(video.src);
      resolve({
        width: video.videoWidth,
        height: video.videoHeight,
        duration: video.duration,
        fileSize: file.size,
      });
    };

    video.onerror = () => {
      URL.revokeObjectURL(video.src);
      reject(new Error("Failed to load video metadata"));
    };

    video.src = URL.createObjectURL(file);
  });
}

export function formatFileSize(bytes: number): string {
  if (bytes === 0) return "0 Bytes";

  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}

export async function upscaleVideo(
  file: File,
  options: UpscaleOptions,
  onProgress: (progress: number) => void,
  abortSignal?: AbortSignal
): Promise<{ blob: Blob; fileSize: number }> {
  return new Promise((resolve, reject) => {
    const sourceVideo = document.createElement("video");
    sourceVideo.src = URL.createObjectURL(file);
    sourceVideo.muted = true;

    const targetDimensions = resolutionSettings[options.resolution];
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d", { alpha: false });

    if (!ctx) {
      reject(new Error("Failed to get canvas context"));
      return;
    }

    // Handle abort signal
    let isAborted = false;
    let mediaRecorder: MediaRecorder | null = null;

    if (abortSignal) {
      if (abortSignal.aborted) {
        reject(new Error("Operation cancelled"));
        return;
      }
      abortSignal.addEventListener("abort", () => {
        isAborted = true;
        sourceVideo.pause();
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          mediaRecorder.stop();
        }
        reject(new Error("Operation cancelled"));
      });
    }

    sourceVideo.onloadedmetadata = () => {
      // Decide which side to fit based on orientation to keep original aspect ratio with NO black bars.
      let newWidth: number;
      let newHeight: number;

      if (sourceVideo.videoWidth >= sourceVideo.videoHeight) {
        // Landscape – fit width to target width
        const scale = targetDimensions.width / sourceVideo.videoWidth;
        newWidth = targetDimensions.width;
        newHeight = Math.round(sourceVideo.videoHeight * scale);
      } else {
        // Portrait – fit height to target height
        const scale = targetDimensions.height / sourceVideo.videoHeight;
        newHeight = targetDimensions.height;
        newWidth = Math.round(sourceVideo.videoWidth * scale);
      }

      // Resize canvas to the exact scaled dimensions (no letterboxing)
      canvas.width = newWidth;
      canvas.height = newHeight;

      // Create MediaRecorder with appropriate settings
      const videoStream = canvas.captureStream();
      const audioStream = sourceVideo.captureStream().getAudioTracks()[0];
      if (audioStream) {
        videoStream.addTrack(audioStream);
      }

      // We always record WebM (browser-supported); MP4 will be generated by transcoding later.
      const mimeType = "video/webm;codecs=vp9,opus";

      mediaRecorder = new MediaRecorder(videoStream, {
        mimeType,
        videoBitsPerSecond: options.bitrate * 1000000,
      });

      const chunks: Blob[] = [];

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          chunks.push(e.data);
        }
      };

      mediaRecorder.onstop = () => {
        if (isAborted) return; // Don't process if aborted
        URL.revokeObjectURL(sourceVideo.src);
        const webmBlob = new Blob(chunks, { type: "video/webm" });

        // If target is MP4, transcode using ffmpeg.wasm
        if (options.format === "mp4") {
          (async () => {
            if (isAborted) return; // Don't start FFmpeg if aborted
            // Import from correct paths for FFmpeg v0.12.x
            const { FFmpeg } = await import("@ffmpeg/ffmpeg");
            const { fetchFile } = await import("@ffmpeg/ffmpeg/dist/esm/utils");

            const ffmpeg = new FFmpeg();
            ffmpeg.on("log", ({ message }: any) => {
              console.log(message);
            });

            await ffmpeg.load();
            if (isAborted) return; // Check abort before heavy processing

            // Write the input file
            await ffmpeg.writeFile("input.webm", await fetchFile(webmBlob));

            // Run the conversion
            await ffmpeg.exec([
              "-i",
              "input.webm",
              "-c:v",
              "libx264",
              "-c:a",
              "aac",
              "-b:a",
              "192k",
              "output.mp4",
            ]);

            // Read the output file
            const data = await ffmpeg.readFile("output.mp4");
            const mp4Blob = new Blob([data], { type: "video/mp4" });
            resolve({ blob: mp4Blob, fileSize: mp4Blob.size });
          })().catch((err) => {
            console.error("FFmpeg MP4 conversion failed:", err);
            // Fallback to returning WebM
            resolve({ blob: webmBlob, fileSize: webmBlob.size });
          });
        } else {
          // Return WebM directly
          resolve({ blob: webmBlob, fileSize: webmBlob.size });
        }
      };

      sourceVideo.play();
      mediaRecorder.start(1000);

      let lastProcessedTime = 0;
      const videoDuration = sourceVideo.duration;

      function processFrame() {
        if (isAborted) return; // Stop processing frames if aborted
        if (sourceVideo.ended || sourceVideo.paused) {
          if (mediaRecorder && mediaRecorder.state !== "inactive") {
            mediaRecorder.stop();
          }
          return;
        }

        // Draw video directly to fit canvas preserving aspect ratio (no padding)
        ctx.drawImage(sourceVideo, 0, 0, newWidth, newHeight);

        const currentProgress = (sourceVideo.currentTime / videoDuration) * 100;
        if (
          Math.floor(currentProgress) >
          Math.floor((lastProcessedTime / videoDuration) * 100)
        ) {
          onProgress(Math.floor(currentProgress));
          lastProcessedTime = sourceVideo.currentTime;
        }

        requestAnimationFrame(processFrame);
      }

      processFrame();
    };

    sourceVideo.onerror = () => {
      URL.revokeObjectURL(sourceVideo.src);
      reject(new Error("Error loading video file"));
    };
  });
}
